/*
 * Modbus.c
 *
 *  Created on: 2019年8月17日
 *      Author: Breuning
 */
#include "Modbus.h"
#include <string.h>
#include "Cloud.h"
#include "tim.h"
#include "LED.h"
#include "usart.h"

RS485_UART RS485Uart=
{
	.RX_ProcessSta = 0,
	.RX_State = 0,
	.RX_Len = 0,
};
uint8_t RS485_RX[RS485_RX_LEN] = { 0 };
uint8_t ModbusBuf[RS485_RX_LEN]= { 0 };
uint8_t ModbusBuf_TX[RS485_TX_LEN]= { 0 };


MODBUS Modbus={0};

void MODBUS_Save485Data(void)
{
	if(RS485Uart.RX_State == RS485_RX_IMCOMPLETE)
	{
		ModbusBuf[RS485Uart.RX_Len++] = RS485_RX[0];

		if(ModbusBuf[SLAVE_DEV_ADDR_NUM] != SLAVE_DEV_ADDR_VALUE)
		{
			RS485Uart.RX_Len=0;
			return;
		}

		if((ModbusBuf[FUNC_NUM] != WRITE_FUN_VALUE)&&(ModbusBuf[FUNC_NUM] != READ_FUN_VALUE)&&(RS485Uart.RX_Len == 2))
		{
			RS485Uart.RX_Len=0;
			return;
		}

		switch(ModbusBuf[FUNC_NUM])
		{
			case WRITE_FUN_VALUE:
				if(RS485Uart.RX_Len>=RS485_RX_WRITE_COUNT)
				{
					RS485Uart.RX_Len=0;
					RS485Uart.RX_State = RS485_RX_WRITE_COMPLETE;
					RS485Uart_RX_TX_Switch(TRANSMIT);                 		//485接收完毕，发送打开
				}
				break;
			case READ_FUN_VALUE:
				if(RS485Uart.RX_Len>=RS485_RX_READ_COUNT)
				{
					RS485Uart.RX_Len=0;
					RS485Uart.RX_State = RS485_RX_READ_COMPLETE;
					RS485Uart_RX_TX_Switch(TRANSMIT);                 		//485接收完毕，发送打开
				}
				break;
			default:
				break;
		}

	}

}

void ModbusDataRecv(void)
{
	if(RS485Uart.RX_State == RS485_RX_WRITE_COMPLETE)
	{

		if(ModbusDataReceive_TimerFlag == TRUE)              		//通过TIM2设置为每5秒进行一次对收到Modbus数据包的解析
		{
			ModbusDataAnalysis(ModbusBuf,RS485_RX_WRITE_COUNT);

			LED2_RS485_Blink();

			memset(ModbusBuf,0,sizeof(ModbusBuf));
			RS485Uart_RX_TX_Switch(RECEIVE);                		//485接收打开，发送截止
			RS485Uart.RX_State = RS485_RX_IMCOMPLETE;
			ModbusDataReceive_TimerFlag = FALSE;
		}
	}

	if(RS485Uart.RX_State == RS485_RX_READ_COMPLETE)
	{
		ModBus_MCUID_Ack(ModbusBuf,RS485_RX_READ_COUNT);



		memset(ModbusBuf,0,sizeof(ModbusBuf));
		RS485Uart_RX_TX_Switch(RECEIVE);                		//485接收打开，发送截止
		RS485Uart.RX_State = RS485_RX_IMCOMPLETE;
	}

}

void ModbusDataAnalysis(uint8_t *modbusbuf,uint8_t bufLen)
{

	if(bufLen < RX_EFCT_DATA_OFFSET_NUM)                            //接收到的一帧数据长度肯定大于7
	{
		return;
	}

	Modbus.CRC_VAL= (modbusbuf[bufLen-2]<<8)|modbusbuf[bufLen-1];  //数据包中的CRC校验值
	Modbus.CHECK_CRC= CRC16(modbusbuf,bufLen-2);                   //计算得到的CRC校验值
	if(Modbus.CRC_VAL != Modbus.CHECK_CRC)
	{
	  Modbus.ERR_CODE = CRC_ERR;
	  return;
	}

	else
	{
		Modbus.DEV_ADDR = modbusbuf[SLAVE_DEV_ADDR_NUM];                                    //从机地址
        Modbus.FUN_CODE = modbusbuf[FUNC_NUM];                                              //功能码
		Modbus.REG_ADDR = (modbusbuf[REG_ADDR_HIGH_NUM]<<8)|modbusbuf[REG_ADDR_LOW_NUM];    //寄存器起始地址
		Modbus.REG_QUAN  = (modbusbuf[REG_NUM_HIGH_NUM]<<8)|modbusbuf[REG_NUM_LOW_NUM];     //寄存器数量
        if(Modbus.DEV_ADDR == SLAVE_DEV_ADDR_VALUE)
        {
			switch(Modbus.FUN_CODE)
			{
				case READ_FUN_VALUE:
					//memcpy(Modbus.RX_DATA,(uint8_t*)(modbusbuf+RX_EFCT_DATA_OFFSET_NUM),Modbus.REG_CNT);
					//ReadData(&Modbus,Modbus.REG_CNT/2);
					//Modbus.ERR_Code=0;
					break;
				case WRITE_FUN_VALUE:
					if(Modbus.REG_ADDR != 0)                    //寄存器起始地址需为0，即数据从地址0开始写
						return;
					memcpy(Modbus.RX_DATA,(uint8_t*)(modbusbuf+RX_EFCT_DATA_OFFSET_NUM),(Modbus.REG_QUAN)*2);   //将第7个字节后的数据值放到Modbus.RX_DATA
					WriteMultiRegister(Modbus.RX_DATA);
					break;
				default:
					Modbus.FUN_CODE = FUN_ERR;
					break;
			}
		}
        else
        {
            Modbus.FUN_CODE = FUN_ERR;
        }
    }
}

void WriteMultiRegister(uint8_t *databuf)
{
	hcloud.ibsRealData[0]  = ((databuf[0]<<8)|databuf[1]);      	//年
	hcloud.ibsRealData[1]  = ((databuf[2]<<8)|databuf[3]);      	//月
	hcloud.ibsRealData[2]  = ((databuf[4]<<8)|databuf[5]);      	//日
	hcloud.ibsRealData[3]  = ((databuf[6]<<8)|databuf[7]);      	//时
	hcloud.ibsRealData[4]  = ((databuf[8]<<8)|databuf[9]);      	//分
	hcloud.ibsRealData[5]  = ((databuf[10]<<8)|databuf[11]);    	//秒
	hcloud.ibsRealData[6]  = ((databuf[12]<<8)|databuf[13])/10.0; 	//室外温度
	hcloud.ibsRealData[7]  = ((databuf[14]<<8)|databuf[15])/10.0; 	//平均温度
	hcloud.ibsRealData[8]  = ((databuf[16]<<8)|databuf[17])/10.0;	//温度1
	hcloud.ibsRealData[9]  = ((databuf[18]<<8)|databuf[19])/10.0;	//湿度
	hcloud.ibsRealData[10] = ((databuf[20]<<8)|databuf[21])/10.0;   //温度2
	hcloud.ibsRealData[11] = ((databuf[22]<<8)|databuf[23])/10.0;   //温度3
	hcloud.ibsRealData[12] = ((databuf[24]<<8)|databuf[25])/10.0;   //水温
	hcloud.ibsRealData[13] = ((databuf[26]<<8)|databuf[27]);        //负压
	hcloud.ibsRealData[14] = ((databuf[28]<<8)|databuf[29]);        //CO2
	hcloud.ibsRealData[15] = ((databuf[30]<<8)|databuf[31]);        //NH3
	hcloud.ibsRealData[16] = ((databuf[32]<<8)|databuf[33]);        //当前日龄
	hcloud.ibsRealData[17] = ((databuf[34]<<8)|databuf[35])/10.0;   //目标温度
	hcloud.ibsRealData[18] = ((databuf[36]<<8)|databuf[37]);        //风机状态              12位
	hcloud.ibsRealData[19] = ((databuf[38]<<8)|databuf[39]);        //小窗状态                4位
	hcloud.ibsRealData[20] = ((databuf[40]<<8)|databuf[41]);        //加热状态                4位
	hcloud.ibsRealData[21] = ((databuf[42]<<8)|databuf[43]);        //湿帘状态                3位
	hcloud.ibsRealData[22] = ((databuf[44]<<8)|databuf[45]);        //报警状态                1位
	hcloud.ibsRealData[23] = ((databuf[46]<<8)|databuf[47]);        //自动状态     1+1+1+1位
}

void ModBus_MCUID_Ack(uint8_t *modbusbuf,uint8_t bufLen)
{
	uint8_t i;

	Modbus.CRC_VAL= (modbusbuf[bufLen-2]<<8)|modbusbuf[bufLen-1];  //数据包中的CRC校验值
	Modbus.CHECK_CRC= CRC16(modbusbuf,bufLen-2);                   //计算得到的CRC校验值
	if(Modbus.CRC_VAL != Modbus.CHECK_CRC)
	{
	  Modbus.ERR_CODE = CRC_ERR;
	  return;
	}

	else
	{
		Get_MCUUID();
		ModbusBuf_TX[SLAVE_DEV_ADDR_NUM] = SLAVE_DEV_ADDR_VALUE;
		ModbusBuf_TX[FUNC_NUM ] = READ_FUN_VALUE;
		ModbusBuf_TX[2] = 48;

        for(i = 0; i < 24; i++)
        {
        	ModbusBuf_TX[i*2+4] = (uint8_t)hcloud.McuId[i];
        }
        ModbusBuf_TX[51] = CRC16(ModbusBuf_TX,51) >> 8;
        ModbusBuf_TX[52] = CRC16(ModbusBuf_TX,51) & 0xff;

        HAL_UART_Transmit(&huart4, (uint8_t *)ModbusBuf_TX, sizeof(ModbusBuf_TX), 1000);      //将MCUID通过modbus协议发送至PLC
	}

}

void RS485Uart_RX_TX_Switch(RS485_STATE RS485state)
{
	if(RS485state == TRANSMIT)
		HAL_GPIO_WritePin(RS485_SEL_GPIO_Port, RS485_SEL_Pin, GPIO_PIN_SET);		//拉高RS485_SEL脚，RS485为发送状态
	if(RS485state == RECEIVE)
		HAL_GPIO_WritePin(RS485_SEL_GPIO_Port, RS485_SEL_Pin, GPIO_PIN_RESET);		//拉低RS485_SEL脚，RS485为接收状态
}


const unsigned char auchCRCHi[] =
 {
    0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
    0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
    0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
    0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
    0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
    0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
    0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
    0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
    0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
    0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
    0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
    0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
    0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
    0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
    0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
    0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
    0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
    0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
    0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
    0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
    0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
    0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
    0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
    0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
    0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
    0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
    0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
    0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
    0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
    0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
    0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
    0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40
};

const unsigned char auchCRCLo[] =
{
    0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,
    0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4,0x04,
    0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,
    0x0A,0xCA,0xCB,0x0B,0xC9,0x09,0x08,0xC8,
    0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,
    0x1E,0xDE,0xDF,0x1F,0xDD,0x1D,0x1C,0xDC,
    0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,
    0xD2,0x12,0x13,0xD3,0x11,0xD1,0xD0,0x10,
    0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,
    0x36,0xF6,0xF7,0x37,0xF5,0x35,0x34,0xF4,
    0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,
    0xFA,0x3A,0x3B,0xFB,0x39,0xF9,0xF8,0x38,
    0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,
    0xEE,0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,
    0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,
    0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,
    0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,0x62,
    0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,
    0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,0x6E,0xAE,
    0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,
    0x78,0xB8,0xB9,0x79,0xBB,0x7B,0x7A,0xBA,
    0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,
    0xB4,0x74,0x75,0xB5,0x77,0xB7,0xB6,0x76,
    0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,
    0x50,0x90,0x91,0x51,0x93,0x53,0x52,0x92,
    0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,
    0x9C,0x5C,0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,
    0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,
    0x88,0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,
    0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
    0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,
    0x82,0x42,0x43,0x83,0x41,0x81,0x80,0x40
};

unsigned int CRC16(unsigned char *puchMsg, unsigned int usDataLen)
{
	unsigned char uchCRCHi = 0xFF;
	unsigned char uchCRCLo = 0xFF;
	unsigned char uIndex ;

	while (usDataLen--)
	{
		uIndex = uchCRCHi ^ *puchMsg++;
		uchCRCHi = uchCRCLo ^ auchCRCHi[uIndex];
		uchCRCLo = auchCRCLo[uIndex];
	}
	return (uchCRCHi << 8 | uchCRCLo);
}





